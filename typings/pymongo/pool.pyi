"""
This type stub file was generated by pyright.
"""

import contextlib
import platform
import sys
from bson.son import SON
from pymongo import __version__
from pymongo.errors import PyMongoError
from typing import Any, Optional

_MAX_TCP_KEEPIDLE = 300
_MAX_TCP_KEEPINTVL = 10
_MAX_TCP_KEEPCNT = 9
if sys.platform == 'win32':
    ...
else:
    def _set_tcp_option(sock, tcp_option, max_value):
        ...
    
    def _set_keepalive_times(sock):
        ...
    
_METADATA = SON([('driver', SON([('name', 'PyMongo'), ('version', __version__)]))])
if sys.platform.startswith('linux'):
    ...
else:
    ...
if platform.python_implementation().startswith('PyPy'):
    ...
else:
    ...
def _raise_connection_failure(address, error, msg_prefix: Optional[Any] = ...):
    """Convert a socket.error to ConnectionFailure and raise it."""
    ...

class PoolOptions(object):
    __slots__ = ...
    def __init__(self, max_pool_size=..., min_pool_size=..., max_idle_time_seconds: Optional[Any] = ..., connect_timeout: Optional[Any] = ..., socket_timeout: Optional[Any] = ..., wait_queue_timeout: Optional[Any] = ..., wait_queue_multiple: Optional[Any] = ..., ssl_context: Optional[Any] = ..., ssl_match_hostname: bool = ..., socket_keepalive: bool = ..., event_listeners: Optional[Any] = ..., appname: Optional[Any] = ..., driver: Optional[Any] = ..., compression_settings: Optional[Any] = ...):
        ...
    
    @property
    def non_default_options(self):
        """The non-default options this pool was created with.

        Added for CMAP's :class:`PoolCreatedEvent`.
        """
        ...
    
    @property
    def max_pool_size(self):
        """The maximum allowable number of concurrent connections to each
        connected server. Requests to a server will block if there are
        `maxPoolSize` outstanding connections to the requested server.
        Defaults to 100. Cannot be 0.

        When a server's pool has reached `max_pool_size`, operations for that
        server block waiting for a socket to be returned to the pool. If
        ``waitQueueTimeoutMS`` is set, a blocked operation will raise
        :exc:`~pymongo.errors.ConnectionFailure` after a timeout.
        By default ``waitQueueTimeoutMS`` is not set.
        """
        ...
    
    @property
    def min_pool_size(self):
        """The minimum required number of concurrent connections that the pool
        will maintain to each connected server. Default is 0.
        """
        ...
    
    @property
    def max_idle_time_seconds(self):
        """The maximum number of seconds that a connection can remain
        idle in the pool before being removed and replaced. Defaults to
        `None` (no limit).
        """
        ...
    
    @property
    def connect_timeout(self):
        """How long a connection can take to be opened before timing out.
        """
        ...
    
    @property
    def socket_timeout(self):
        """How long a send or receive on a socket can take before timing out.
        """
        ...
    
    @property
    def wait_queue_timeout(self):
        """How long a thread will wait for a socket from the pool if the pool
        has no free sockets.
        """
        ...
    
    @property
    def wait_queue_multiple(self):
        """Multiplied by max_pool_size to give the number of threads allowed
        to wait for a socket at one time.
        """
        ...
    
    @property
    def ssl_context(self):
        """An SSLContext instance or None.
        """
        ...
    
    @property
    def ssl_match_hostname(self):
        """Call ssl.match_hostname if cert_reqs is not ssl.CERT_NONE.
        """
        ...
    
    @property
    def socket_keepalive(self):
        """Whether to send periodic messages to determine if a connection
        is closed.
        """
        ...
    
    @property
    def event_listeners(self):
        """An instance of pymongo.monitoring._EventListeners.
        """
        ...
    
    @property
    def appname(self):
        """The application name, for sending with ismaster in server handshake.
        """
        ...
    
    @property
    def driver(self):
        """Driver name and version, for sending with ismaster in handshake.
        """
        ...
    
    @property
    def compression_settings(self):
        ...
    
    @property
    def metadata(self):
        """A dict of metadata about the application, driver, os, and platform.
        """
        ...
    


class SocketInfo(object):
    """Store a socket with some metadata.

    :Parameters:
      - `sock`: a raw socket object
      - `pool`: a Pool instance
      - `address`: the server's (host, port)
      - `id`: the id of this socket in it's pool
    """
    def __init__(self, sock, pool, address, id):
        self.sock = ...
        self.address = ...
        self.id = ...
        self.authset = ...
        self.closed = ...
        self.last_checkin_time = ...
        self.performed_handshake = ...
        self.is_writable = ...
        self.max_wire_version = ...
        self.max_bson_size = ...
        self.max_message_size = ...
        self.max_write_batch_size = ...
        self.supports_sessions = ...
        self.is_mongos = ...
        self.op_msg_enabled = ...
        self.listeners = ...
        self.enabled_for_cmap = ...
        self.compression_settings = ...
        self.compression_context = ...
        self.pool_id = ...
        self.ready = ...
    
    def ismaster(self, metadata, cluster_time):
        self.is_writable = ...
        self.max_wire_version = ...
        self.max_bson_size = ...
        self.max_message_size = ...
        self.max_write_batch_size = ...
        self.supports_sessions = ...
        self.is_mongos = ...
        self.performed_handshake = ...
        self.op_msg_enabled = ...
    
    def command(self, dbname, spec, slave_ok: bool = ..., read_preference=..., codec_options=..., check: bool = ..., allowable_errors: Optional[Any] = ..., check_keys: bool = ..., read_concern: Optional[Any] = ..., write_concern: Optional[Any] = ..., parse_write_concern_error: bool = ..., collation: Optional[Any] = ..., session: Optional[Any] = ..., client: Optional[Any] = ..., retryable_write: bool = ..., publish_events: bool = ..., user_fields: Optional[Any] = ...):
        """Execute a command or raise an error.

        :Parameters:
          - `dbname`: name of the database on which to run the command
          - `spec`: a command document as a dict, SON, or mapping object
          - `slave_ok`: whether to set the SlaveOkay wire protocol bit
          - `read_preference`: a read preference
          - `codec_options`: a CodecOptions instance
          - `check`: raise OperationFailure if there are errors
          - `allowable_errors`: errors to ignore if `check` is True
          - `check_keys`: if True, check `spec` for invalid keys
          - `read_concern`: The read concern for this command.
          - `write_concern`: The write concern for this command.
          - `parse_write_concern_error`: Whether to parse the
            ``writeConcernError`` field in the command response.
          - `collation`: The collation for this command.
          - `session`: optional ClientSession instance.
          - `client`: optional MongoClient for gossipping $clusterTime.
          - `retryable_write`: True if this command is a retryable write.
          - `publish_events`: Should we publish events for this command?
          - `user_fields` (optional): Response fields that should be decoded
            using the TypeDecoders from codec_options, passed to
            bson._decode_all_selective.
        """
        ...
    
    def send_message(self, message, max_doc_size):
        """Send a raw BSON message or raise ConnectionFailure.

        If a network exception is raised, the socket is closed.
        """
        ...
    
    def receive_message(self, request_id):
        """Receive a raw BSON message or raise ConnectionFailure.

        If any exception is raised, the socket is closed.
        """
        ...
    
    def _raise_if_not_writable(self, unacknowledged):
        """Raise NotMasterError on unacknowledged write if this socket is not
        writable.
        """
        ...
    
    def legacy_write(self, request_id, msg, max_doc_size, with_last_error):
        """Send OP_INSERT, etc., optionally returning response as a dict.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `request_id`: an int.
          - `msg`: bytes, an OP_INSERT, OP_UPDATE, or OP_DELETE message,
            perhaps with a getlasterror command appended.
          - `max_doc_size`: size in bytes of the largest document in `msg`.
          - `with_last_error`: True if a getlasterror command is appended.
        """
        ...
    
    def write_command(self, request_id, msg):
        """Send "insert" etc. command, returning response as a dict.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `request_id`: an int.
          - `msg`: bytes, the command message.
        """
        ...
    
    def check_auth(self, all_credentials):
        """Update this socket's authentication.

        Log in or out to bring this socket's credentials up to date with
        those provided. Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `all_credentials`: dict, maps auth source to MongoCredential.
        """
        ...
    
    def authenticate(self, credentials):
        """Log in to the server and store these credentials in `authset`.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `credentials`: A MongoCredential.
        """
        ...
    
    def validate_session(self, client, session):
        """Validate this session before use with client.

        Raises error if this session is logged in as a different user or
        the client is not the one that created the session.
        """
        ...
    
    def close_socket(self, reason):
        """Close this connection with a reason."""
        self.closed = ...
    
    def send_cluster_time(self, command, session, client):
        """Add cluster time for MongoDB >= 3.6."""
        ...
    
    def update_last_checkin_time(self):
        self.last_checkin_time = ...
    
    def update_is_writable(self, is_writable):
        self.is_writable = ...
    
    def idle_time_seconds(self):
        """Seconds since this socket was last checked into its pool."""
        ...
    
    def _raise_connection_failure(self, error):
        ...
    
    def __eq__(self, other):
        ...
    
    def __ne__(self, other):
        ...
    
    def __hash__(self):
        ...
    
    def __repr__(self):
        ...
    


def _create_connection(address, options):
    """Given (host, port) and PoolOptions, connect and return a socket object.

    Can raise socket.error.

    This is a modified version of create_connection from CPython >= 2.7.
    """
    ...

_PY37PLUS = sys.version_info[: 2] >= (3, 7)
def _configured_socket(address, options):
    """Given (host, port) and PoolOptions, return a configured socket.

    Can raise socket.error, ConnectionFailure, or CertificateError.

    Sets socket's SSL and timeout options.
    """
    ...

class _PoolClosedError(PyMongoError):
    """Internal error raised when a thread tries to get a connection from a
    closed pool.
    """
    ...


class Pool:
    def __init__(self, address, options, handshake: bool = ...):
        """
        :Parameters:
          - `address`: a (hostname, port) tuple
          - `options`: a PoolOptions instance
          - `handshake`: whether to call ismaster for each new SocketInfo
        """
        self.sockets = ...
        self.lock = ...
        self.active_sockets = ...
        self.next_connection_id = ...
        self.closed = ...
        self.is_writable = ...
        self.pool_id = ...
        self.pid = ...
        self.address = ...
        self.opts = ...
        self.handshake = ...
        self.enabled_for_cmap = ...
        self.socket_checker = ...
    
    def _reset(self, close):
        ...
    
    def update_is_writable(self, is_writable):
        """Updates the is_writable attribute on all sockets currently in the
        Pool.
        """
        self.is_writable = ...
    
    def reset(self):
        ...
    
    def close(self):
        ...
    
    def remove_stale_sockets(self, reference_pool_id):
        """Removes stale sockets then adds new ones if pool is too small and
        has not been reset. The `reference_pool_id` argument specifies the
        `pool_id` at the point in time this operation was requested on the
        pool.
        """
        ...
    
    def connect(self):
        """Connect to Mongo and return a new SocketInfo.

        Can raise ConnectionFailure or CertificateError.

        Note that the pool does not keep a reference to the socket -- you
        must call return_socket() when you're done with it.
        """
        ...
    
    @contextlib.contextmanager
    def get_socket(self, all_credentials, checkout: bool = ...):
        """Get a socket from the pool. Use with a "with" statement.

        Returns a :class:`SocketInfo` object wrapping a connected
        :class:`socket.socket`.

        This method should always be used in a with-statement::

            with pool.get_socket(credentials, checkout) as socket_info:
                socket_info.send_message(msg)
                data = socket_info.receive_message(op_code, request_id)

        The socket is logged in or out as needed to match ``all_credentials``
        using the correct authentication mechanism for the server's wire
        protocol version.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `all_credentials`: dict, maps auth source to MongoCredential.
          - `checkout` (optional): keep socket checked out.
        """
        ...
    
    def _get_socket_no_auth(self):
        """Get or create a SocketInfo. Can raise ConnectionFailure."""
        ...
    
    def return_socket(self, sock_info, publish_checkin: bool = ...):
        """Return the socket to the pool, or if it's closed discard it.

        :Parameters:
          - `sock_info`: The socket to check into the pool.
          - `publish_checkin`: If False, a ConnectionCheckedInEvent will not
            be published.
        """
        ...
    
    def _perished(self, sock_info):
        """This side-effecty function checks if this socket has been idle for
        for longer than the max idle time, or if the socket has been closed by
        some external network error.

        Checking sockets lets us avoid seeing *some*
        :class:`~pymongo.errors.AutoReconnect` exceptions on server
        hiccups, etc. We only check if the socket was closed by an external
        error if it has been > 1 second since the socket was checked into the
        pool, to keep performance reasonable - we can't avoid AutoReconnects
        completely anyway.
        """
        ...
    
    def _raise_wait_queue_timeout(self):
        ...
    
    def __del__(self):
        ...
    


