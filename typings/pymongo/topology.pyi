"""
This type stub file was generated by pyright.
"""

from bson.py3compat import PY3
from typing import Any, Optional

"""Internal class to monitor a topology of one or more servers."""
if PY3:
    ...
else:
    ...
def process_events_queue(queue_ref):
    ...

class Topology(object):
    """Monitor a topology of one or more servers."""
    def __init__(self, topology_settings):
        ...
    
    def open(self):
        """Start monitoring, or restart after a fork.

        No effect if called multiple times.

        .. warning:: Topology is shared among multiple threads and is protected
          by mutual exclusion. Using Topology from a process other than the one
          that initialized it will emit a warning and may result in deadlock. To
          prevent this from happening, MongoClient must be created after any
          forking.

        """
        ...
    
    def select_servers(self, selector, server_selection_timeout: Optional[Any] = ..., address: Optional[Any] = ...):
        """Return a list of Servers matching selector, or time out.

        :Parameters:
          - `selector`: function that takes a list of Servers and returns
            a subset of them.
          - `server_selection_timeout` (optional): maximum seconds to wait.
            If not provided, the default value common.SERVER_SELECTION_TIMEOUT
            is used.
          - `address`: optional server address to select.

        Calls self.open() if needed.

        Raises exc:`ServerSelectionTimeoutError` after
        `server_selection_timeout` if no matching servers are found.
        """
        ...
    
    def _select_servers_loop(self, selector, timeout, address):
        """select_servers() guts. Hold the lock when calling this."""
        ...
    
    def select_server(self, selector, server_selection_timeout: Optional[Any] = ..., address: Optional[Any] = ...):
        """Like select_servers, but choose a random server if several match."""
        ...
    
    def select_server_by_address(self, address, server_selection_timeout: Optional[Any] = ...):
        """Return a Server for "address", reconnecting if necessary.

        If the server's type is not known, request an immediate check of all
        servers. Time out after "server_selection_timeout" if the server
        cannot be reached.

        :Parameters:
          - `address`: A (host, port) pair.
          - `server_selection_timeout` (optional): maximum seconds to wait.
            If not provided, the default value
            common.SERVER_SELECTION_TIMEOUT is used.

        Calls self.open() if needed.

        Raises exc:`ServerSelectionTimeoutError` after
        `server_selection_timeout` if no matching servers are found.
        """
        ...
    
    def _process_change(self, server_description):
        """Process a new ServerDescription on an opened topology.

        Hold the lock when calling this.
        """
        ...
    
    def on_change(self, server_description):
        """Process a new ServerDescription after an ismaster call completes."""
        ...
    
    def _process_srv_update(self, seedlist):
        """Process a new seedlist on an opened topology.
        Hold the lock when calling this.
        """
        ...
    
    def on_srv_update(self, seedlist):
        """Process a new list of nodes obtained from scanning SRV records."""
        ...
    
    def get_server_by_address(self, address):
        """Get a Server or None.

        Returns the current version of the server immediately, even if it's
        Unknown or absent from the topology. Only use this in unittests.
        In driver code, use select_server_by_address, since then you're
        assured a recent view of the server's type and wire protocol version.
        """
        ...
    
    def has_server(self, address):
        ...
    
    def get_primary(self):
        """Return primary's address or None."""
        ...
    
    def _get_replica_set_members(self, selector):
        """Return set of replica set member addresses."""
        ...
    
    def get_secondaries(self):
        """Return set of secondary addresses."""
        ...
    
    def get_arbiters(self):
        """Return set of arbiter addresses."""
        ...
    
    def max_cluster_time(self):
        """Return a document, the highest seen $clusterTime."""
        ...
    
    def _receive_cluster_time_no_lock(self, cluster_time):
        ...
    
    def receive_cluster_time(self, cluster_time):
        ...
    
    def request_check_all(self, wait_time=...):
        """Wake all monitors, wait for at least one to check its server."""
        ...
    
    def reset_pool(self, address):
        ...
    
    def reset_server(self, address):
        """Clear our pool for a server and mark it Unknown.

        Do *not* request an immediate check.
        """
        ...
    
    def reset_server_and_request_check(self, address):
        """Clear our pool for a server, mark it Unknown, and check it soon."""
        ...
    
    def mark_server_unknown_and_request_check(self, address):
        """Mark a server Unknown, and check it soon."""
        ...
    
    def update_pool(self):
        ...
    
    def close(self):
        """Clear pools and terminate monitors. Topology reopens on demand."""
        ...
    
    @property
    def description(self):
        ...
    
    def pop_all_sessions(self):
        """Pop all session ids from the pool."""
        ...
    
    def get_server_session(self):
        """Start or resume a server session, or raise ConfigurationError."""
        ...
    
    def return_server_session(self, server_session, lock):
        ...
    
    def _new_selection(self):
        """A Selection object, initially including all known servers.

        Hold the lock when calling this.
        """
        ...
    
    def _ensure_opened(self):
        """Start monitors, or restart after a fork.

        Hold the lock when calling this.
        """
        ...
    
    def _reset_server(self, address, reset_pool):
        """Mark a server Unknown and optionally reset it's pool.

        Hold the lock when calling this. Does *not* request an immediate check.
        """
        ...
    
    def _request_check(self, address):
        """Wake one monitor. Hold the lock when calling this."""
        ...
    
    def _request_check_all(self):
        """Wake all monitors. Hold the lock when calling this."""
        ...
    
    def _update_servers(self):
        """Sync our Servers from TopologyDescription.server_descriptions.

        Hold the lock while calling this.
        """
        ...
    
    def _create_pool_for_server(self, address):
        ...
    
    def _create_pool_for_monitor(self, address):
        ...
    
    def _error_message(self, selector):
        """Format an error message if server selection fails.

        Hold the lock when calling this.
        """
        ...
    


